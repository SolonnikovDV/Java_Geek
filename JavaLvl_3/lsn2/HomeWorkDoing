package lsn2.HomeWorkDoing;

import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;

class Arr {
    static final int ARR_SIZE = 10;
    static final int MAX = 1001;
    static final int MIN = 0;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int findValue, delValue;
        int[] cloneArr = createArr(ARR_SIZE, MAX, MIN).clone();
        printArr(cloneArr);

        // вставка
        System.out.println(Arrays.toString(insert(cloneArr, 2222)));

        // поиск
        System.out.print("Enter the value of element you want to find : ");
        findValue = scanner.nextInt();
        System.out.println(find(cloneArr, findValue));

        // удаление
        System.out.print("Enter the value of element you want to delete : ");
        delValue = scanner.nextInt();
        delete(cloneArr, delValue);

        // выполнение сортировок с вычислением времени для каждого вида сортировки
        calcSortBubbleRuntime(createArr(ARR_SIZE, MAX, MIN));

        calcSortInsretRuntime(createArr(ARR_SIZE, MAX, MIN));

        calcSortSelectRuntime(createArr(ARR_SIZE, MAX, MIN));

    }

    // создание неотсортированного массива и его заполнение случайными числами (объединены п. 1 и п. 2 ДЗ)
    // на вход принимает размер массива и верхнюю + нижнюю границы диапазона случайно генерируемых натуральных чисел
    static int[] createArr(int size, int max, int min) {
        int[] mass = new int[size];
        for (int i = 0; i < size; i++) {
            mass[i] = new Random().nextInt((max - min) + 1) + min;
        }
        return mass;
    }

    // метод удаления элемента миссива
    static void delete(int[] mass, int search) {
        int len = mass.length;
        int index;

        for (index = 0; index < len; index++) {
            if (mass[index] == search)
                break;
        }
        for (int j = index; j < len - 1; j++) {
            mass[j] = mass[j + 1];
        }
        len--;
        System.out.println("print new massive");
        for (int j = 0; j < len; j++) {
            System.out.print(mass[j] + " ");
        }
        System.out.println();
    }

    // линейный поиск
    static boolean find(int[] mass, int value) {
        boolean b = false;
        int len = mass.length;
        for (int i = 0; i < len; i++) {
            if (mass[i] == value) {
                b = true;
                break;
            }
        }
        return b;
    }

    // метод добавления элемента
    static int[] insert(int[] mass, int value) {
        int len = mass.length;
        int[] cloneMass = new int[len + 1];
        System.arraycopy(mass, 0, cloneMass, 0, len);
        cloneMass[len] = value;
        return cloneMass;
    }

    // пузырьковая сортировка
    static void sortBubble(int[] mass) {
        int in, out;
        int len = mass.length;
        // внешний цикл
        for (out = len - 1; out >= 1; out--) {
            // внутренний цикл
            for (in = 0; in < out; in++) {
                if (mass[in] > mass[in + 1]) {
                    change(in, in + 1, mass);
                }
            }
        }
    }

    // сортировка выбором (маркером)
    static void sortSelect(int[] mass) {
        int in, out, mark;
        int len = mass.length;
        for (out = 0; out < len; out++) {
            mark = out;
            for (in = out + 1; in < len; in++) {
                if (mass[in] < mass[mark]) {
                    mark = in;
                }
            }
            change(out, mark, mass);
        }
    }

    // сортировка вставкой
    static void sortInsert(int[] mass) {
        int in, out;
        int len = mass.length;
        for (out = 1; out < len; out++) {
            int temp = mass[out];
            in = out;
            while (in > 0 && mass[in - 1] >= temp) {
                mass[in] = mass[in - 1];
                --in;
            }
            mass[in] = temp;
        }
    }

    static void change(int a, int b, int[] mass) {
        int temp = mass[a];
        mass[a] = mass[b];
        mass[b] = temp;
    }

    static void calcSortBubbleRuntime(int[] mass) {
        int[] cloneArr = mass.clone();
        System.out.println("sortBubble" + "\n" + "Not sorted array: ");
        printArr(cloneArr);
        double start = System.currentTimeMillis();
        sortBubble(cloneArr);
        double end = System.currentTimeMillis();
        System.out.println("Sorted array: ");
        printArr(cloneArr);
        System.out.println("Sort operation time: " + (end - start));
    }

    static void calcSortInsretRuntime(int[] mass) {
        int[] cloneArr = mass.clone();
        System.out.println("sortInsert" + "\n" + "Not sorted array: ");
        printArr(cloneArr);
        double start = System.currentTimeMillis();
        sortBubble(cloneArr);
        double end = System.currentTimeMillis();
        System.out.println("Sorted array: ");
        printArr(cloneArr);
        System.out.println("Sort operation time: " + (end - start));
    }

    static void calcSortSelectRuntime(int[] mass) {
        int[] cloneArr = mass.clone();
        System.out.println("sortSelect" + "\n" + "Not sorted array: ");
        printArr(cloneArr);
        double start = System.currentTimeMillis();
        sortBubble(cloneArr);
        double end = System.currentTimeMillis();
        System.out.println("Sorted array: ");
        printArr(cloneArr);
        System.out.println("Sort operation time: " + (end - start));
    }

    // вывод массива в консоль
    static void printArr(int[] mass) {
        System.out.println(Arrays.toString(mass));
    }

//    static double checkRuntime(int[] mass) {
//        double start, end, difference;
//        start = System.currentTimeMillis();
//        sortBubble(mass);
//        end = System.currentTimeMillis();
//        difference = end - start;
//        return difference;
//    }

}
